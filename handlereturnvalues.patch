diff --git a/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp b/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp
index 6f409f578fa330caf8c48e80bc5fab97f58058dc..007676ff1c048bf46e1040765b355078d7e9eb27 100644
--- a/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp
+++ b/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp
@@ -1,54 +1,75 @@
-
 // AudioDeviceMiniaudio.cpp
 
 #include "pch.h"
 #include "AudioDeviceMiniAudio.hpp"
 #include "Log.hpp"
 
 AudioDeviceMiniaudio::AudioDeviceMiniaudio(int channels, int sampleRate, int bufferFrames) {
-	ma_engine_config cfg = ma_engine_config_init();
-	cfg.listenerCount = 1;          // stereo
-	cfg.sampleRate = sampleRate;
-	cfg.channels = channels;
-	// setup the data callback:
-	cfg.dataCallback = nullptr;     // well open a raw device instead of engine_playSource
-
-	ma_context_init(nullptr, 0, nullptr, &context_);
-	
-	ma_device_config dc = ma_device_config_init(ma_device_type_playback);
-	dc.playback.format = ma_format_f32;
-	dc.playback.channels = channels;
-	dc.sampleRate = sampleRate;
-	dc.periodSizeInFrames = bufferFrames;		// e.g. 2048
-	dc.periods = 2;	
-
-
-	
-	dc.dataCallback = AudioDeviceMiniaudio::dataCallback;
-	dc.pUserData = this;
-	
-	ma_device_init(&context_, &dc, &device_);
-	ma_device_start(&device_);
-
-	
-	LogMessage("AudioDeviceMiniaudio::AudioDeviceMiniaudio: DONE.", LogCategory::AudioDevice, LogLevel::Debug);
+        ma_engine_config cfg = ma_engine_config_init();
+        cfg.listenerCount = 1;          // stereo
+        cfg.sampleRate = sampleRate;
+        cfg.channels = channels;
+        // setup the data callback:
+        cfg.dataCallback = nullptr;     // well open a raw device instead of engine_playSource
+
+        ma_result r = ma_context_init(nullptr, 0, nullptr, &context_);
+        if (r != MA_SUCCESS) {
+                LogMessage("ma_context_init failed: " + std::string(ma_result_description(r)), LogCategory::AudioDevice, LogLevel::Error);
+                processingEnabled_ = false;
+                return;
+        }
+        contextInitialized_ = true;
+
+        ma_device_config dc = ma_device_config_init(ma_device_type_playback);
+        dc.playback.format = ma_format_f32;
+        dc.playback.channels = channels;
+        dc.sampleRate = sampleRate;
+        dc.periodSizeInFrames = bufferFrames;           // e.g. 2048
+        dc.periods = 2;
+
+
+
+        dc.dataCallback = AudioDeviceMiniaudio::dataCallback;
+        dc.pUserData = this;
+
+        r = ma_device_init(&context_, &dc, &device_);
+        if (r != MA_SUCCESS) {
+                LogMessage("ma_device_init failed: " + std::string(ma_result_description(r)), LogCategory::AudioDevice, LogLevel::Error);
+                processingEnabled_ = false;
+                return;
+        }
+        deviceInitialized_ = true;
+
+        r = ma_device_start(&device_);
+        if (r != MA_SUCCESS) {
+                LogMessage("ma_device_start failed: " + std::string(ma_result_description(r)), LogCategory::AudioDevice, LogLevel::Error);
+                processingEnabled_ = false;
+                return;
+        }
+
+
+        LogMessage("AudioDeviceMiniaudio::AudioDeviceMiniaudio: DONE.", LogCategory::AudioDevice, LogLevel::Debug);
 }
 
 AudioDeviceMiniaudio::~AudioDeviceMiniaudio() {
-	ma_device_uninit(&device_);
-	ma_context_uninit(&context_);
+        if (deviceInitialized_) {
+                ma_device_uninit(&device_);
+        }
+        if (contextInitialized_) {
+                ma_context_uninit(&context_);
+        }
 }
 
 SoundHandle AudioDeviceMiniaudio::Play(AudioBuffer* buf, float volume, float pitch, bool loop) {
-	// Obsolete! were driving PCM manually in render-callbackno per-voice backend here.
-	return 0;
+        // Obsolete! were driving PCM manually in render-callbackno per-voice backend here.
+        return 0;
 }
 
 void AudioDeviceMiniaudio::Stop(SoundHandle) { /* no-op for manual mix */ }
 void AudioDeviceMiniaudio::SetVolume(SoundHandle, float) { /* track in Voice */ }
 void AudioDeviceMiniaudio::SetPitch(SoundHandle, float) { /* track in Voice */ }
 
 void AudioDeviceMiniaudio::SetRenderCallback(std::function<void(float*, int)> cb) {
-	std::lock_guard<std::mutex> lk(cbMutex_);
-	renderCb_ = std::move(cb);
+        std::lock_guard<std::mutex> lk(cbMutex_);
+        renderCb_ = std::move(cb);
 }
diff --git a/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp b/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp
index 2e1a71914d3a23507c424eaaefe767827c0a373d..5465a20c5f834976250db2a95807469d3dc06fc2 100644
--- a/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp
+++ b/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp
@@ -1,39 +1,42 @@
 // AudioDeviceMiniaudio.hpp
 #pragma once
 #include "AudioDevice.hpp"
 #include "miniaudio.h"
 #include <functional>
 #include <mutex>
 #include <unordered_map>
 
 class AudioDeviceMiniaudio : public AudioDevice {
 public:
     AudioDeviceMiniaudio(int channels, int sampleRate, int bufferFrames);
     ~AudioDeviceMiniaudio();
 
     SoundHandle Play(AudioBuffer* buf, float volume, float pitch, bool loop)    override;
     void Stop(SoundHandle handle)                                               override;
     void SetVolume(SoundHandle, float)                                          override;
     void SetPitch(SoundHandle, float)                                           override;
     void SetRenderCallback(std::function<void(float*, int)> cb)                 override;
 
 private:
     ma_engine engine_{};
     ma_context context_{};
     ma_device device_{};
     std::function<void(float*, int)> renderCb_;
     std::mutex                   cbMutex_;
+    bool                         contextInitialized_{false};
+    bool                         deviceInitialized_{false};
+    bool                         processingEnabled_{true};
 
     static void dataCallback(ma_device* pDevice, void* pOutput, const void*, ma_uint32 frameCount) {
         auto* self = static_cast<AudioDeviceMiniaudio*>(pDevice->pUserData);
         float* out = static_cast<float*>(pOutput);
         std::lock_guard<std::mutex> lk(self->cbMutex_);
-        if (self->renderCb_) {
+        if (self->processingEnabled_ && self->renderCb_) {
             self->renderCb_(out, frameCount);
         }
         else {
             // silence if no callback set
             std::fill(out, out + frameCount * pDevice->playback.channels, 0.f);
         }
     }
 };
