diff --git a/DeclarativeSoundEngine/AudioDevice.hpp b/DeclarativeSoundEngine/AudioDevice.hpp
index f5cf5ffecd7086378adb70c37472e7befa69e078..2885281ca592f65c20ea2d0ee5676a1b389e444d 100644
--- a/DeclarativeSoundEngine/AudioDevice.hpp
+++ b/DeclarativeSoundEngine/AudioDevice.hpp
@@ -1,30 +1,30 @@
 // AudioDevice.hpp
 #pragma once
 #include "AudioBuffer.hpp"
 #include <functional>
 
 
 enum AudioBackend : int {
 	Miniaudio = 0,
 	Unity = 1
 };
 
 struct AudioConfig {
 	AudioBackend backend;
 	uint32_t     sampleRate;
 	uint32_t     bufferFrames;
 	uint32_t     channels;
 };
 
 using SoundHandle = uint32_t;
 
 struct AudioDevice {
 	virtual ~AudioDevice() = default;
 	virtual SoundHandle Play(AudioBuffer* buffer, float volume, float pitch, bool loop) = 0;
 	virtual void Stop(SoundHandle handle) = 0;
-	virtual void SetVolume(SoundHandle handle, float volume) = 0;
-	virtual void SetPitch(SoundHandle handle, float pitch) = 0;
-	virtual void SetRenderCallback(std::function<void(float*, int)> cb) = 0;
-	//virtual int GetBufferSize() = 0;
+        virtual void SetVolume(SoundHandle handle, float volume) = 0;
+        virtual void SetPitch(SoundHandle handle, float pitch) = 0;
+        virtual void SetRenderCallback(std::function<void(float*, int)> cb) = 0;
+        virtual uint32_t GetBufferFrames() const = 0;
 
 };
\ No newline at end of file
diff --git a/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp b/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp
index 55f942d7448f3cab2335de94333366f40a779e2f..c96f793fc689378f49e97fc6733a8cc487ece0a6 100644
--- a/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp
+++ b/DeclarativeSoundEngine/AudioDeviceMiniAudio.cpp
@@ -16,62 +16,71 @@ AudioDeviceMiniaudio::AudioDeviceMiniaudio(int channels, int sampleRate, int buf
     if (r != MA_SUCCESS) {
         LogMessage("ma_context_init failed: " + std::string(ma_result_description(r)), LogCategory::AudioDevice, LogLevel::Error);
         processingEnabled_ = false;
         return;
     }
     contextInitialized_ = true;
 
     ma_device_config dc = ma_device_config_init(ma_device_type_playback);
     dc.playback.format = ma_format_f32;
     dc.playback.channels = channels;
     dc.sampleRate = sampleRate;
     dc.periodSizeInFrames = bufferFrames;           // e.g. 2048
     dc.periods = 2;
 
 
 
     dc.dataCallback = AudioDeviceMiniaudio::dataCallback;
     dc.pUserData = this;
 
     r = ma_device_init(&context_, &dc, &device_);
     if (r != MA_SUCCESS) {
         LogMessage("ma_device_init failed: " + std::string(ma_result_description(r)), LogCategory::AudioDevice, LogLevel::Error);
         processingEnabled_ = false;
         return;
     }
+    bufferFrames_ = device_.playback.internalPeriodSizeInFrames;
+    if (bufferFrames_ != dc.periodSizeInFrames) {
+        LogMessage("[Miniaudio] Requested period " + std::to_string(dc.periodSizeInFrames) + " got " + std::to_string(bufferFrames_), LogCategory::AudioDevice, LogLevel::Info);
+    }
     deviceInitialized_ = true;
 
     r = ma_device_start(&device_);
     if (r != MA_SUCCESS) {
         LogMessage("ma_device_start failed: " + std::string(ma_result_description(r)), LogCategory::AudioDevice, LogLevel::Error);
         processingEnabled_ = false;
         return;
     }
 
 
     LogMessage("AudioDeviceMiniaudio::AudioDeviceMiniaudio: DONE.", LogCategory::AudioDevice, LogLevel::Debug);
 }
 
 AudioDeviceMiniaudio::~AudioDeviceMiniaudio() {
     if (deviceInitialized_) {
         ma_device_uninit(&device_);
     }
     if (contextInitialized_) {
         ma_context_uninit(&context_);
     }
 }
 
 SoundHandle AudioDeviceMiniaudio::Play(AudioBuffer* buf, float volume, float pitch, bool loop) {
 	// Obsolete! were driving PCM manually in render-callbackno per-voice backend here.
 	return 0;
 }
 
 void AudioDeviceMiniaudio::Stop(SoundHandle) { /* no-op for manual mix */ }
 void AudioDeviceMiniaudio::SetVolume(SoundHandle, float) { /* track in Voice */ }
 void AudioDeviceMiniaudio::SetPitch(SoundHandle, float) { /* track in Voice */ }
 
 void AudioDeviceMiniaudio::SetRenderCallback(std::function<void(float*, int)> cb) {
 	std::lock_guard<std::mutex> lk(cbMutex_);
 	renderCb_ = std::move(cb);
 }
 
 
+
+uint32_t AudioDeviceMiniaudio::GetBufferFrames() const {
+    return bufferFrames_;
+}
+
diff --git a/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp b/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp
index 3baeeaeb1d2f66a7e671297efea8b004157844a3..1f0d48735350fc7d9b2f7fc50fe07b57625ece71 100644
--- a/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp
+++ b/DeclarativeSoundEngine/AudioDeviceMiniAudio.hpp
@@ -1,42 +1,44 @@
 // AudioDeviceMiniaudio.hpp
 #pragma once
 #include "AudioDevice.hpp"
 #include "miniaudio.h"
 #include <functional>
 #include <mutex>
 #include <unordered_map>
 
 class AudioDeviceMiniaudio : public AudioDevice {
 public:
     AudioDeviceMiniaudio(int channels, int sampleRate, int bufferFrames);
     ~AudioDeviceMiniaudio();
 
     SoundHandle Play(AudioBuffer* buf, float volume, float pitch, bool loop)    override;
     void Stop(SoundHandle handle)                                               override;
     void SetVolume(SoundHandle, float)                                          override;
     void SetPitch(SoundHandle, float)                                           override;
     void SetRenderCallback(std::function<void(float*, int)> cb)                 override;
+    uint32_t GetBufferFrames() const override { return bufferFrames_; }
    // int GetBufferSize() override;
 private:
     ma_engine                           engine_{};
     ma_context                          context_{};
     ma_device                           device_{};
     bool                                contextInitialized_{ false };
     bool                                deviceInitialized_{ false };
     bool                                processingEnabled_{ true };
     std::function<void(float*, int)>    renderCb_;
     std::mutex                          cbMutex_;
+    uint32_t                            bufferFrames_{};
 
     static void dataCallback(ma_device* pDevice, void* pOutput, const void*, ma_uint32 frameCount) {
         auto* self = static_cast<AudioDeviceMiniaudio*>(pDevice->pUserData);
         float* out = static_cast<float*>(pOutput);
         std::lock_guard<std::mutex> lk(self->cbMutex_);
         if (self->processingEnabled_ && self->renderCb_) {
             self->renderCb_(out, frameCount);
         }
         else {
             // silence if no callback set
             std::fill(out, out + frameCount * pDevice->playback.channels, 0.f);
         }
     }
 };
diff --git a/DeclarativeSoundEngine/AudioDeviceUnity.cpp b/DeclarativeSoundEngine/AudioDeviceUnity.cpp
index ead307258ee8938a342ca507f594aeafcbe225aa..4ce911acb1003fe69efcced4f0f87e733d2c85a4 100644
--- a/DeclarativeSoundEngine/AudioDeviceUnity.cpp
+++ b/DeclarativeSoundEngine/AudioDeviceUnity.cpp
@@ -1,37 +1,38 @@
 #include "pch.h"
 #include "AudioDeviceUnity.hpp"
 #include "Log.hpp"
 #include "UnityAudioPluginBridge.h"    // Unity's audio plugin SDK
 #include <cstring>
 
 
 static AudioDeviceUnity* s_Device = nullptr;
 static std::function<void(float*, int)> s_RenderCallback;
 
 AudioDeviceUnity::AudioDeviceUnity(int channels, int sampleRate, int bufferFrames) {
     LogMessage("[UnityDevice] init.", LogCategory::AudioDevice, LogLevel::Debug);
+    bufferFrames_ = bufferFrames;
     s_Device = this;
 }
 
 AudioDeviceUnity::~AudioDeviceUnity() {
     LogMessage("[UnityDevice] shutdown.", LogCategory::AudioDevice, LogLevel::Debug);
     s_Device = nullptr;
 }
 
 SoundHandle AudioDeviceUnity::Play(AudioBuffer* buf, float volume, float pitch, bool loop) {
     // No-op: Unity drives mixing directly
     return SoundHandle();
 }
 
 void AudioDeviceUnity::Stop(SoundHandle handle) {
     // No-op
 }
 
 void AudioDeviceUnity::SetVolume(SoundHandle handle, float volume) {
     // No-op
 }
 
 void AudioDeviceUnity::SetPitch(SoundHandle handle, float pitch) {
     // No-op
 }
 
diff --git a/DeclarativeSoundEngine/AudioDeviceUnity.hpp b/DeclarativeSoundEngine/AudioDeviceUnity.hpp
index 076d664f62b371695f8cec2579a8bee244929993..a5c986421af768820500ec26fed8e3eed4f68bae 100644
--- a/DeclarativeSoundEngine/AudioDeviceUnity.hpp
+++ b/DeclarativeSoundEngine/AudioDeviceUnity.hpp
@@ -1,15 +1,18 @@
 #pragma once
 #include "AudioDevice.hpp"
 
 
 class AudioDeviceUnity : public AudioDevice {
 public:
 	AudioDeviceUnity(int channels, int sampleRate, int bufferFrames);
 	~AudioDeviceUnity();
 
 	SoundHandle Play(AudioBuffer* buf, float volume, float pitch, bool loop)	override;
 	void Stop(SoundHandle handle)												override;
 	void SetVolume(SoundHandle, float)											override;
 	void SetPitch(SoundHandle, float)											override;
 	void SetRenderCallback(std::function<void(float*, int)> cb)					override;
+        uint32_t GetBufferFrames() const override { return bufferFrames_; }
+private:
+        uint32_t bufferFrames_{};
 };
\ No newline at end of file
diff --git a/DeclarativeSoundEngine/AudioManager.cpp b/DeclarativeSoundEngine/AudioManager.cpp
index 3564e4f0ff7ef5d2d5ddcd61476aa8f041616fe2..4f51a12eb0b15e7e5dcc852090fdb8754c3b744e 100644
--- a/DeclarativeSoundEngine/AudioManager.cpp
+++ b/DeclarativeSoundEngine/AudioManager.cpp
@@ -12,72 +12,76 @@
 #include "BehaviorLoader.hpp"
 #include "AudioDevice.hpp"
 #include "Log.hpp"
 
 const double M_PI = 3.14159265358979323846;
 
 namespace {
 	Snapshot::Snapshot gSnapshots[Snapshot::kSnapCount];   // single, file-local definition
 }
 
 AudioManager::AudioManager(AudioConfig* deviceCfg, CommandQueue* inQueue, CommandQueue* outQueue)
 	:deviceCfg(deviceCfg), inQueue(inQueue), outQueue(outQueue) {
 
 	LogMessage("INIT", LogCategory::AudioManager, LogLevel::Debug);
 
 	bufferManager = new AudioBufferManager(deviceCfg->sampleRate);
 	LogMessage("... create audio device", LogCategory::AudioManager, LogLevel::Debug);
 
 	// create audio device
 	switch (deviceCfg->backend) {
 	case AudioBackend::Miniaudio: { device = std::make_unique<AudioDeviceMiniaudio>(deviceCfg->channels, deviceCfg->sampleRate, deviceCfg->bufferFrames); break; }
 	case AudioBackend::Unity: { device = std::make_unique<AudioDeviceUnity>(deviceCfg->channels, deviceCfg->sampleRate, deviceCfg->bufferFrames); break; }
 	default: { LogMessage("unknown audio device!", LogCategory::AudioManager, LogLevel::Warning);break; }
 	}
 
-	LogMessage("... create buffers", LogCategory::AudioManager, LogLevel::Debug);
+        LogMessage("... create buffers", LogCategory::AudioManager, LogLevel::Debug);
 
-	// size buffers
-	size_t bufSamples = size_t(deviceCfg->bufferFrames * deviceCfg->channels);
+        uint32_t realFrames = device->GetBufferFrames();
+        if (realFrames != deviceCfg->bufferFrames) {
+                LogMessage("[AudioDevice] requested period " + std::to_string(deviceCfg->bufferFrames) +
+                        " got " + std::to_string(realFrames), LogCategory::AudioDevice, LogLevel::Info);
+        }
 
-	for (Snapshot::Snapshot& snap : gSnapshots)
-		for (int b = 0; b < Snapshot::kMaxBuses; ++b)
-			//snap.bus[b].resize(bufSamples, 0.0f);
-			std::memset(snap.bus[b], 0, bufSamples * sizeof(float));
+        size_t bufSamples = size_t(realFrames * deviceCfg->channels);
+
+        for (Snapshot::Snapshot& snap : gSnapshots)
+                for (int b = 0; b < Snapshot::kMaxBuses; ++b)
+                        snap.bus[b].resize(bufSamples, 0.0f);
 	LogMessage("... set callback", LogCategory::AudioManager, LogLevel::Debug);
 
 	// set callback
 	// TODO: REENABLE
 	device->SetRenderCallback(
 		[this](float* output, int frameCount) {RenderCallback(output, frameCount); });
 
 
 	LogMessage("... create master bus", LogCategory::AudioManager, LogLevel::Debug);
 
 	// Create Master Bus at buses[0]
-	buses.clear();
-	buses.push_back({ std::vector<float>(deviceCfg->bufferFrames * deviceCfg->channels),{} }); // master
+        buses.clear();
+        buses.push_back({ std::vector<float>(realFrames * deviceCfg->channels),{} }); // master
 	LogMessage("... Init Done.", LogCategory::AudioManager, LogLevel::Debug);
 
 	LogMessage("... starting buffertest.", LogCategory::AudioManager, LogLevel::Debug);
 
 
 
 
 	// BufferTest();
 
 }
 void AudioManager::BufferTest() {
 
 
 	const int numVoices = 255;
 	const int frames = deviceCfg->bufferFrames;
 	const int channels = deviceCfg->channels;
 	std::vector<float> outBuffer(frames * channels);  // This will be your "fake audio output"
 
 	// create a dummy buffer
 	auto dummyBuf = new AudioBuffer("");
 	dummyBuf->channelCount = channels;
 	dummyBuf->frameCount = frames * 2;  // give it some length
 	dummyBuf->samples.resize(frames * 2 * channels, 0.25f);  // fill with audible dummy data
 
 	// set as loaded
@@ -304,52 +308,53 @@ void AudioManager::TakeSnapshot()
 
 
 void AudioManager::AdvancePlayheads()
 {
 	uint32_t step = pendingFrames.exchange(0, std::memory_order_acquire);
 	if (step == 0) return;
 
 	for (auto& [eid, ed] : entities)
 		for (auto& inst : ed.GetBehaviors())
 			for (auto& v : inst.GetVoices()) {
 				if (!v.buffer) continue;
 				if (v.buffer->Empty()) continue; // TODO: buffer not ready. but this would offset our start, right? not sure how to properly handle this tbh...?
 				size_t len = v.buffer->GetFrameCount();
 				if (v.loop)
 					v.playhead = (v.playhead + step) % len;
 				else
 					v.playhead = (std::min)(v.playhead + step, len);
 			}
 }
 
 
 int AudioManager::GetOrCreateBus(const std::string& entityId) {
 	auto it = entityBus.find(entityId);
 	if (it != entityBus.end()) return it->second;
 	// allocate new sub‐bus
-	int newIndex = (int)buses.size();
-	buses.push_back({ std::vector<float>(deviceCfg->bufferFrames * deviceCfg->channels), {} });
+        int newIndex = (int)buses.size();
+        uint32_t frames = device->GetBufferFrames();
+        buses.push_back({ std::vector<float>(frames * deviceCfg->channels), {} });
 	entityBus.emplace(entityId, newIndex);
 
 	//LogMessage("[BUS] added new bus for entity: " + entityId, LogCategory::AudioManager, LogLevel::Debug);
 	return newIndex;
 }
 
 
 void AudioManager::SetTag(Command cmd) {
 	std::string entityId = cmd.entityId;
 	auto* tag = std::get_if<std::string>(&cmd.value);
 	auto& entity = entities[entityId]; // create if missing
 	entity.SetBus(GetOrCreateBus(entityId));
 	entity.SetTag(*tag);
 
 	if (*tag == "listener")
 		currentListener = cmd.entityId;
 
 	LogMessage("Tag set: e: " + entityId + " t: " + *tag, LogCategory::AudioManager, LogLevel::Debug);
 }
 void AudioManager::SetTransient(Command cmd) {
 	std::string entityId = cmd.entityId;
 	auto* tag = std::get_if<std::string>(&cmd.value);
 	auto& entity = entities[entityId];
 	entity.SetTransientTag(*tag);
 }
@@ -411,56 +416,56 @@ void AudioManager::DebugPrintState()
 			if (e.second.GetValues().TryGetValue(n, vv)) {
 				LogMessage("    - " + n + ": " + "("
 					+ std::to_string(vv.x) + ", "
 					+ std::to_string(vv.y) + ", "
 					+ std::to_string(vv.z) + ")", LogCategory::AudioManager, LogLevel::Debug);
 			}
 		}
 
 		LogMessage("  behaviors: ", LogCategory::AudioManager, LogLevel::Debug);
 		for (auto& ab : e.second.GetBehaviors()) {
 			LogMessage("    - " + ab.Name(), LogCategory::AudioManager, LogLevel::Debug);
 		}
 	}
 }
 
 
 void AudioManager::RenderCallback(float* out, int frames) {
 	auto t0 = std::chrono::high_resolution_clock::now();
 	const auto& s = gSnapshots[currentReadBuffer.load()];
 	int bufferSize = frames * deviceCfg->channels; // e.g. 2048 frames × 2 = 4096
 
 	// 1) Zero the master once
 	std::memset(out, 0, bufferSize * sizeof(float));
 
 	// 2) Iterate each sub‐bus B = 1..(busCount−1)
-	for (uint32_t B = 1; B < s.busCount; ++B) {
-		float* busBuf = s.bus[B];
-		float  bGain = s.busGain[B];
+        for (uint32_t B = 1; B < s.busCount; ++B) {
+                float* busBuf = s.bus[B].data();
+                float  bGain = s.busGain[B];
 
 		// 2a) Zero this bus buffer
-		std::memset(busBuf, 0, bufferSize * sizeof(float));
+                std::memset(busBuf, 0, bufferSize * sizeof(float));
 
 		// 2b) Mix each voice in bus B
 		uint32_t nVoices = s.numVoicesInBus[B];
 		for (uint32_t vi = 0; vi < nVoices; ++vi) {
 			uint32_t vIndex = s.voicesByBus[B][vi];        // which entry in s.voices[]
 			const auto& vs = s.voices[vIndex];
 			const float* pcm = vs.buf->GetData();
 			size_t        ph = vs.playhead;               // in frames
 			float         gL = vs.gain * vs.pan[0];
 			float         gR = vs.gain * vs.pan[1];
 			size_t totalFrames = vs.buf->GetFrameCount();   // e.g. 4096
 			size_t totalSamples = vs.buf->GetSampleCount();   // e.g. 22050×2 = 44100
 			size_t bufferFrames = frames;                              // how many frames to render now
 			size_t bufferSize = bufferFrames * deviceCfg->channels;  // e.g. 2048×2 = 4096 floats
 
 			int srcChannels = vs.buf->GetChannelCount();
 			int dstChannels = deviceCfg->channels;
 
 			
 			// 1) If ph is already out of range, handle that first:
 			if (ph >= totalFrames) {
 				if (vs.loop) {
 					ph %= totalFrames;
 				}
 				else {
@@ -576,75 +581,74 @@ void AudioManager::RenderCallback(float* out, int frames) {
 
 		auto t_sn0 = std::chrono::high_resolution_clock::now();
 		// load snapshot
 		int front = currentReadBuffer.load(std::memory_order_acquire);
 		const Snapshot::Snapshot& s = gSnapshots[front];
 		auto t_sn1 = std::chrono::high_resolution_clock::now();
 		LogMessage("load snapshot time: " + std::to_string((t_sn1 - t_sn0).count()) + "ns", LogCategory::AudioManager, LogLevel::Debug);
 
 		/*
 		if (s.voiceCount == 0) {
 			std::memset(out, 0, frames * deviceCfg->channels * sizeof(float));
 			pendingFrames.fetch_add(frames, std::memory_order_relaxed);
 			globalSampleCounter += frames;
 			cbBlockIndex.fetch_add(1, std::memory_order_release);
 			return;
 		}
 		*/
 
 
 
 		uint64_t blockStart = globalSampleCounter;
 		int samples = frames * deviceCfg->channels;
 		auto t_fill0 = std::chrono::high_resolution_clock::now();
 
 		// clear bus buffers
-		for (uint32_t b = 0; b < s.busCount; ++b)
-			std::memset(s.bus[b], 0, samples * sizeof(float));
-		//std::fill(s.bus[b].begin(), s.bus[b].end(), 0.0f);
+                for (uint32_t b = 0; b < s.busCount; ++b)
+                        std::fill(s.bus[b].begin(), s.bus[b].end(), 0.0f);
 
 		auto t_fill1 = std::chrono::high_resolution_clock::now();
 		LogMessage("Clear time: " + std::to_string((t_fill1 - t_fill0).count()) + "ns", LogCategory::AudioManager, LogLevel::Debug);
 
 
 		auto t_mix0 = std::chrono::high_resolution_clock::now();
 		// mix voices
 		for (uint32_t v = 0; v < s.voiceCount; ++v)
 		{
 			const Snapshot::VoiceSnap& vs = s.voices[v];
 			if (!vs.buf || vs.buf->Empty()) continue;
 
 
 			const float* pcm = vs.buf->GetData();
 			const int ch = vs.buf->GetChannelCount();       // source channels
 			const size_t len = vs.buf->GetFrameCount();     // source frame count
 			size_t pos = size_t(vs.playhead);               // current playhead
 
 			const float gainL = vs.gain * vs.pan[0];        // pre-multiplied gain per channel
 			const float gainR = vs.gain * vs.pan[1];
 
-			float* busBuf = s.bus[vs.bus];
+                        float* busBuf = s.bus[vs.bus].data();
 
 			//LogMessage("Voice #" + std::to_string(v) + ": frames=" + std::to_string(vs.buf->GetFrameCount()), LogCategory::AudioManager, LogLevel::Debug);
 
 			if (ch == 1) {
 				// Mono source → pan into stereo bus
 				for (int i = 0; i < frames; ++i) {
 					float sample = 0.f;
 					if (pos < len)
 						sample = pcm[pos];
 					else if (vs.loop)
 						sample = pcm[pos % len];  // still has % but only if looping
 					else
 						break;
 
 					busBuf[i * 2 + 0] += sample * gainL;
 					busBuf[i * 2 + 1] += sample * gainR;
 
 					++pos;
 				}
 			}
 			else if (ch == 2) {
 				// Stereo source
 				for (int i = 0; i < frames; ++i) {
 					if (pos >= len && !vs.loop) break;
 
@@ -670,71 +674,71 @@ void AudioManager::RenderCallback(float* out, int frames) {
 					if (frameIndex >= len && vs.loop)
 						frameIndex %= len;
 
 					for (uint32_t c = 0; c < deviceCfg->channels; ++c) {
 						float s = pcm[frameIndex * ch + (c % ch)] * vs.gain * vs.pan[c];
 						busBuf[i * deviceCfg->channels + c] += s;
 					}
 
 					++pos;
 				}
 			}
 		}
 
 		for (uint32_t b = 0; b < s.busCount; ++b) {
 			float maxSample = 0;
 			for (float f : s.bus[b])
 				maxSample = (std::max)(maxSample, std::abs(f));
 		}
 
 
 		auto t_fold0 = std::chrono::high_resolution_clock::now();
 		// fold busses onto master bus (master = buses[0])
 		for (int b = int(s.busCount) - 1; b > 0; --b) {
 			float gain = s.busGain[b];
 			int parent = parent = s.busParent[b];
-			float* src = s.bus[b];
-			float* dst = s.bus[parent];
+                        float* src = s.bus[b].data();
+                        float* dst = s.bus[parent].data();
 			for (int i = 0; i < samples; ++i)
 				dst[i] += src[i] * gain;
 		}
 		auto t_fold1 = std::chrono::high_resolution_clock::now();
 		LogMessage("bus fold time: " + std::to_string((t_fold1 - t_fold0).count()) + "ns", LogCategory::AudioManager, LogLevel::Debug);
 		auto t_mix1 = std::chrono::high_resolution_clock::now();
 		LogMessage("mix time: " + std::to_string((t_mix1 - t_mix0).count()) + "ns", LogCategory::AudioManager, LogLevel::Debug);
 
 
 		// copy to device
 		auto t_mem0 = std::chrono::high_resolution_clock::now();
-		std::memcpy(out, s.bus[0], size_t(frames * deviceCfg->channels) * sizeof(float));
+                std::memcpy(out, s.bus[0].data(), size_t(frames * deviceCfg->channels) * sizeof(float));
 		auto t_mem1 = std::chrono::high_resolution_clock::now();
 		LogMessage("Memcpy time: " + std::to_string((t_mem1 - t_mem0).count()) + "ns", LogCategory::AudioManager, LogLevel::Debug);
 		// advance counters
 
 		pendingFrames.fetch_add(frames, std::memory_order_relaxed);
 		globalSampleCounter += frames; // this might be a little redundant
 		cbBlockIndex.fetch_add(1, std::memory_order_release);
 
 
 
 
 		auto t1 = std::chrono::high_resolution_clock::now();
 		std::chrono::duration<double, std::micro> elapsed = t1 - t0;
 		double elapsedMicros = elapsed.count();  // duration in microseconds
 
 
 
 
 
 		double timeBudget = double(frames) * 1'000'000.0 / deviceCfg->sampleRate;
 		if (elapsedMicros > timeBudget) {
 			LogMessage("RenderCallback OVERRUN: " + std::to_string(elapsedMicros) + "µs (budget: " + std::to_string(timeBudget) + "µs)", LogCategory::AudioManager, LogLevel::Warning);
 		}
 		else {
 			LogMessage("RenderCallback: " + std::to_string(elapsedMicros) + "µs", LogCategory::AudioManager, LogLevel::Debug);
 		}
 		LogMessage("VoiceCount: " + std::to_string(s.voiceCount), LogCategory::AudioManager, LogLevel::Debug);
 		LogMessage("BusCount: " + std::to_string(s.busCount), LogCategory::AudioManager, LogLevel::Debug);
-		LogMessage("Bus0.size: " + std::to_string(sizeof(s.bus[0])), LogCategory::AudioManager, LogLevel::Debug);
+                LogMessage("Bus0.size: " + std::to_string(s.bus[0].size()), LogCategory::AudioManager, LogLevel::Debug);
 
 
 	}
\ No newline at end of file
diff --git a/DeclarativeSoundEngine/Snapshot.hpp b/DeclarativeSoundEngine/Snapshot.hpp
index 1ce06b58ccb509ce8805fc8bde9474bafa5c4987..db3d81276a5bcd4883e71dcaab5b84f37a611c80 100644
--- a/DeclarativeSoundEngine/Snapshot.hpp
+++ b/DeclarativeSoundEngine/Snapshot.hpp
@@ -8,33 +8,33 @@ namespace Snapshot {
 	constexpr int  kMaxBuses  = 256;
 	constexpr int  kSnapCount = 3;
 	constexpr int kMaxVoicesPerBus = 128; // upper bound, or choose smaller if you know max voices/bus
 
 
 	// TODO: RESTRUCTURE TO HAVE A BUS->VOICE reference available. Then use that for mixing.
 
 
 	struct VoiceSnap {
 		const AudioBuffer* buf = nullptr;
 		size_t				playhead = 0;
 		float				gain = 1.0f;
 		bool				loop = false;
 		uint8_t				bus = 0;
 		uint64_t			startSample = 0;
 		float				pan[2] = {1.0f, 1.0f};  // Stereo fixed
 	};
 
 	struct Snapshot {
 		Vec3				listenerPosition = {};
 		uint32_t			voiceCount = 0;
 		VoiceSnap			voices[kMaxVoices];         // contiguous, flat
 		uint32_t			busCount = 1;
 		float				busGain[kMaxBuses]{};
 		int					busParent[kMaxBuses]{};     // flattened from vector
-		mutable float		bus[kMaxBuses][4096]{};     // optionally fixed-size
+		mutable std::vector<float> bus[kMaxBuses];     // dynamic
 		
 		uint32_t			numVoicesInBus[kMaxBuses] = {};
 		uint32_t			voicesByBus[kMaxBuses][kMaxVoicesPerBus] = {};
 
-		// Note: You can re-enable vector-backed bus buffers if dynamic size is needed
+                // Using dynamic vector-backed bus buffers
 	};
 }
